(globalThis.TURBOPACK = globalThis.TURBOPACK || []).push(["static/chunks/node_modules_5e2a24._.js", {

"[project]/node_modules/obliterator/iterator.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
/**
 * Obliterator Iterator Class
 * ===========================
 *
 * Simple class representing the library's iterators.
 */ /**
 * Iterator class.
 *
 * @constructor
 * @param {function} next - Next function.
 */ function Iterator(next) {
    if (typeof next !== 'function') throw new Error('obliterator/iterator: expecting a function!');
    this.next = next;
}
/**
 * If symbols are supported, we add `next` to `Symbol.iterator`.
 */ if (typeof Symbol !== 'undefined') Iterator.prototype[Symbol.iterator] = function() {
    return this;
};
/**
 * Returning an iterator of the given values.
 *
 * @param  {any...} values - Values.
 * @return {Iterator}
 */ Iterator.of = function() {
    var args = arguments, l = args.length, i = 0;
    return new Iterator(function() {
        if (i >= l) return {
            done: true
        };
        return {
            done: false,
            value: args[i++]
        };
    });
};
/**
 * Returning an empty iterator.
 *
 * @return {Iterator}
 */ Iterator.empty = function() {
    var iterator = new Iterator(function() {
        return {
            done: true
        };
    });
    return iterator;
};
/**
 * Returning an iterator over the given indexed sequence.
 *
 * @param  {string|Array} sequence - Target sequence.
 * @return {Iterator}
 */ Iterator.fromSequence = function(sequence) {
    var i = 0, l = sequence.length;
    return new Iterator(function() {
        if (i >= l) return {
            done: true
        };
        return {
            done: false,
            value: sequence[i++]
        };
    });
};
/**
 * Returning whether the given value is an iterator.
 *
 * @param  {any} value - Value.
 * @return {boolean}
 */ Iterator.is = function(value) {
    if (value instanceof Iterator) return true;
    return typeof value === 'object' && value !== null && typeof value.next === 'function';
};
/**
 * Exporting.
 */ module.exports = Iterator;
}}),
"[project]/node_modules/obliterator/support.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
exports.ARRAY_BUFFER_SUPPORT = typeof ArrayBuffer !== 'undefined';
exports.SYMBOL_SUPPORT = typeof Symbol !== 'undefined';
}}),
"[project]/node_modules/obliterator/foreach.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
/**
 * Obliterator ForEach Function
 * =============================
 *
 * Helper function used to easily iterate over mixed values.
 */ var support = __turbopack_require__("[project]/node_modules/obliterator/support.js [app-client] (ecmascript)");
var ARRAY_BUFFER_SUPPORT = support.ARRAY_BUFFER_SUPPORT;
var SYMBOL_SUPPORT = support.SYMBOL_SUPPORT;
/**
 * Function able to iterate over almost any iterable JS value.
 *
 * @param  {any}      iterable - Iterable value.
 * @param  {function} callback - Callback function.
 */ module.exports = function forEach(iterable, callback) {
    var iterator, k, i, l, s;
    if (!iterable) throw new Error('obliterator/forEach: invalid iterable.');
    if (typeof callback !== 'function') throw new Error('obliterator/forEach: expecting a callback.');
    // The target is an array or a string or function arguments
    if (Array.isArray(iterable) || ARRAY_BUFFER_SUPPORT && ArrayBuffer.isView(iterable) || typeof iterable === 'string' || iterable.toString() === '[object Arguments]') {
        for(i = 0, l = iterable.length; i < l; i++)callback(iterable[i], i);
        return;
    }
    // The target has a #.forEach method
    if (typeof iterable.forEach === 'function') {
        iterable.forEach(callback);
        return;
    }
    // The target is iterable
    if (SYMBOL_SUPPORT && Symbol.iterator in iterable && typeof iterable.next !== 'function') {
        iterable = iterable[Symbol.iterator]();
    }
    // The target is an iterator
    if (typeof iterable.next === 'function') {
        iterator = iterable;
        i = 0;
        while(s = iterator.next(), s.done !== true){
            callback(s.value, i);
            i++;
        }
        return;
    }
    // The target is a plain object
    for(k in iterable){
        if (iterable.hasOwnProperty(k)) {
            callback(iterable[k], k);
        }
    }
    return;
};
}}),
"[project]/node_modules/mnemonist/utils/typed-arrays.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
/**
 * Mnemonist Typed Array Helpers
 * ==============================
 *
 * Miscellaneous helpers related to typed arrays.
 */ /**
 * When using an unsigned integer array to store pointers, one might want to
 * choose the optimal word size in regards to the actual numbers of pointers
 * to store.
 *
 * This helpers does just that.
 *
 * @param  {number} size - Expected size of the array to map.
 * @return {TypedArray}
 */ var MAX_8BIT_INTEGER = Math.pow(2, 8) - 1, MAX_16BIT_INTEGER = Math.pow(2, 16) - 1, MAX_32BIT_INTEGER = Math.pow(2, 32) - 1;
var MAX_SIGNED_8BIT_INTEGER = Math.pow(2, 7) - 1, MAX_SIGNED_16BIT_INTEGER = Math.pow(2, 15) - 1, MAX_SIGNED_32BIT_INTEGER = Math.pow(2, 31) - 1;
exports.getPointerArray = function(size) {
    var maxIndex = size - 1;
    if (maxIndex <= MAX_8BIT_INTEGER) return Uint8Array;
    if (maxIndex <= MAX_16BIT_INTEGER) return Uint16Array;
    if (maxIndex <= MAX_32BIT_INTEGER) return Uint32Array;
    throw new Error('mnemonist: Pointer Array of size > 4294967295 is not supported.');
};
exports.getSignedPointerArray = function(size) {
    var maxIndex = size - 1;
    if (maxIndex <= MAX_SIGNED_8BIT_INTEGER) return Int8Array;
    if (maxIndex <= MAX_SIGNED_16BIT_INTEGER) return Int16Array;
    if (maxIndex <= MAX_SIGNED_32BIT_INTEGER) return Int32Array;
    return Float64Array;
};
/**
 * Function returning the minimal type able to represent the given number.
 *
 * @param  {number} value - Value to test.
 * @return {TypedArrayClass}
 */ exports.getNumberType = function(value) {
    // <= 32 bits itnteger?
    if (value === (value | 0)) {
        // Negative
        if (Math.sign(value) === -1) {
            if (value <= 127 && value >= -128) return Int8Array;
            if (value <= 32767 && value >= -32768) return Int16Array;
            return Int32Array;
        } else {
            if (value <= 255) return Uint8Array;
            if (value <= 65535) return Uint16Array;
            return Uint32Array;
        }
    }
    // 53 bits integer & floats
    // NOTE: it's kinda hard to tell whether we could use 32bits or not...
    return Float64Array;
};
/**
 * Function returning the minimal type able to represent the given array
 * of JavaScript numbers.
 *
 * @param  {array}    array  - Array to represent.
 * @param  {function} getter - Optional getter.
 * @return {TypedArrayClass}
 */ var TYPE_PRIORITY = {
    Uint8Array: 1,
    Int8Array: 2,
    Uint16Array: 3,
    Int16Array: 4,
    Uint32Array: 5,
    Int32Array: 6,
    Float32Array: 7,
    Float64Array: 8
};
// TODO: make this a one-shot for one value
exports.getMinimalRepresentation = function(array, getter) {
    var maxType = null, maxPriority = 0, p, t, v, i, l;
    for(i = 0, l = array.length; i < l; i++){
        v = getter ? getter(array[i]) : array[i];
        t = exports.getNumberType(v);
        p = TYPE_PRIORITY[t.name];
        if (p > maxPriority) {
            maxPriority = p;
            maxType = t;
        }
    }
    return maxType;
};
/**
 * Function returning whether the given value is a typed array.
 *
 * @param  {any} value - Value to test.
 * @return {boolean}
 */ exports.isTypedArray = function(value) {
    return typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView(value);
};
/**
 * Function used to concat byte arrays.
 *
 * @param  {...ByteArray}
 * @return {ByteArray}
 */ exports.concat = function() {
    var length = 0, i, o, l;
    for(i = 0, l = arguments.length; i < l; i++)length += arguments[i].length;
    var array = new arguments[0].constructor(length);
    for(i = 0, o = 0; i < l; i++){
        array.set(arguments[i], o);
        o += arguments[i].length;
    }
    return array;
};
/**
 * Function used to initialize a byte array of indices.
 *
 * @param  {number}    length - Length of target.
 * @return {ByteArray}
 */ exports.indices = function(length) {
    var PointerArray = exports.getPointerArray(length);
    var array = new PointerArray(length);
    for(var i = 0; i < length; i++)array[i] = i;
    return array;
};
}}),
"[project]/node_modules/mnemonist/utils/iterables.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
/**
 * Mnemonist Iterable Function
 * ============================
 *
 * Harmonized iteration helpers over mixed iterable targets.
 */ var forEach = __turbopack_require__("[project]/node_modules/obliterator/foreach.js [app-client] (ecmascript)");
var typed = __turbopack_require__("[project]/node_modules/mnemonist/utils/typed-arrays.js [app-client] (ecmascript)");
/**
 * Function used to determine whether the given object supports array-like
 * random access.
 *
 * @param  {any} target - Target object.
 * @return {boolean}
 */ function isArrayLike(target) {
    return Array.isArray(target) || typed.isTypedArray(target);
}
/**
 * Function used to guess the length of the structure over which we are going
 * to iterate.
 *
 * @param  {any} target - Target object.
 * @return {number|undefined}
 */ function guessLength(target) {
    if (typeof target.length === 'number') return target.length;
    if (typeof target.size === 'number') return target.size;
    return;
}
/**
 * Function used to convert an iterable to an array.
 *
 * @param  {any}   target - Iteration target.
 * @return {array}
 */ function toArray(target) {
    var l = guessLength(target);
    var array = typeof l === 'number' ? new Array(l) : [];
    var i = 0;
    // TODO: we could optimize when given target is array like
    forEach(target, function(value) {
        array[i++] = value;
    });
    return array;
}
/**
 * Same as above but returns a supplementary indices array.
 *
 * @param  {any}   target - Iteration target.
 * @return {array}
 */ function toArrayWithIndices(target) {
    var l = guessLength(target);
    var IndexArray = typeof l === 'number' ? typed.getPointerArray(l) : Array;
    var array = typeof l === 'number' ? new Array(l) : [];
    var indices = typeof l === 'number' ? new IndexArray(l) : [];
    var i = 0;
    // TODO: we could optimize when given target is array like
    forEach(target, function(value) {
        array[i] = value;
        indices[i] = i++;
    });
    return [
        array,
        indices
    ];
}
/**
 * Exporting.
 */ exports.isArrayLike = isArrayLike;
exports.guessLength = guessLength;
exports.toArray = toArray;
exports.toArrayWithIndices = toArrayWithIndices;
}}),
"[project]/node_modules/mnemonist/lru-cache.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
/**
 * Mnemonist LRUCache
 * ===================
 *
 * JavaScript implementation of the LRU Cache data structure. To save up
 * memory and allocations this implementation represents its underlying
 * doubly-linked list as static arrays and pointers. Thus, memory is allocated
 * only once at instantiation and JS objects are never created to serve as
 * pointers. This also means this implementation does not trigger too many
 * garbage collections.
 *
 * Note that to save up memory, a LRU Cache can be implemented using a singly
 * linked list by storing predecessors' pointers as hashmap values.
 * However, this means more hashmap lookups and would probably slow the whole
 * thing down. What's more, pointers are not the things taking most space in
 * memory.
 */ var Iterator = __turbopack_require__("[project]/node_modules/obliterator/iterator.js [app-client] (ecmascript)"), forEach = __turbopack_require__("[project]/node_modules/obliterator/foreach.js [app-client] (ecmascript)"), typed = __turbopack_require__("[project]/node_modules/mnemonist/utils/typed-arrays.js [app-client] (ecmascript)"), iterables = __turbopack_require__("[project]/node_modules/mnemonist/utils/iterables.js [app-client] (ecmascript)");
/**
 * LRUCache.
 *
 * @constructor
 * @param {function} Keys     - Array class for storing keys.
 * @param {function} Values   - Array class for storing values.
 * @param {number}   capacity - Desired capacity.
 */ function LRUCache(Keys, Values, capacity) {
    if (arguments.length < 2) {
        capacity = Keys;
        Keys = null;
        Values = null;
    }
    this.capacity = capacity;
    if (typeof this.capacity !== 'number' || this.capacity <= 0) throw new Error('mnemonist/lru-cache: capacity should be positive number.');
    else if (!isFinite(this.capacity) || Math.floor(this.capacity) !== this.capacity) throw new Error('mnemonist/lru-cache: capacity should be a finite positive integer.');
    var PointerArray = typed.getPointerArray(capacity);
    this.forward = new PointerArray(capacity);
    this.backward = new PointerArray(capacity);
    this.K = typeof Keys === 'function' ? new Keys(capacity) : new Array(capacity);
    this.V = typeof Values === 'function' ? new Values(capacity) : new Array(capacity);
    // Properties
    this.size = 0;
    this.head = 0;
    this.tail = 0;
    this.items = {};
}
/**
 * Method used to clear the structure.
 *
 * @return {undefined}
 */ LRUCache.prototype.clear = function() {
    this.size = 0;
    this.head = 0;
    this.tail = 0;
    this.items = {};
};
/**
 * Method used to splay a value on top.
 *
 * @param  {number}   pointer - Pointer of the value to splay on top.
 * @return {LRUCache}
 */ LRUCache.prototype.splayOnTop = function(pointer) {
    var oldHead = this.head;
    if (this.head === pointer) return this;
    var previous = this.backward[pointer], next = this.forward[pointer];
    if (this.tail === pointer) {
        this.tail = previous;
    } else {
        this.backward[next] = previous;
    }
    this.forward[previous] = next;
    this.backward[oldHead] = pointer;
    this.head = pointer;
    this.forward[pointer] = oldHead;
    return this;
};
/**
 * Method used to set the value for the given key in the cache.
 *
 * @param  {any} key   - Key.
 * @param  {any} value - Value.
 * @return {undefined}
 */ LRUCache.prototype.set = function(key, value) {
    var pointer = this.items[key];
    // The key already exists, we just need to update the value and splay on top
    if (typeof pointer !== 'undefined') {
        this.splayOnTop(pointer);
        this.V[pointer] = value;
        return;
    }
    // The cache is not yet full
    if (this.size < this.capacity) {
        pointer = this.size++;
    } else {
        pointer = this.tail;
        this.tail = this.backward[pointer];
        delete this.items[this.K[pointer]];
    }
    // Storing key & value
    this.items[key] = pointer;
    this.K[pointer] = key;
    this.V[pointer] = value;
    // Moving the item at the front of the list
    this.forward[pointer] = this.head;
    this.backward[this.head] = pointer;
    this.head = pointer;
};
/**
 * Method used to set the value for the given key in the cache
 *
 * @param  {any} key   - Key.
 * @param  {any} value - Value.
 * @return {{evicted: boolean, key: any, value: any}} An object containing the
 * key and value of an item that was overwritten or evicted in the set
 * operation, as well as a boolean indicating whether it was evicted due to
 * limited capacity. Return value is null if nothing was evicted or overwritten
 * during the set operation.
 */ LRUCache.prototype.setpop = function(key, value) {
    var oldValue = null;
    var oldKey = null;
    var pointer = this.items[key];
    // The key already exists, we just need to update the value and splay on top
    if (typeof pointer !== 'undefined') {
        this.splayOnTop(pointer);
        oldValue = this.V[pointer];
        this.V[pointer] = value;
        return {
            evicted: false,
            key: key,
            value: oldValue
        };
    }
    // The cache is not yet full
    if (this.size < this.capacity) {
        pointer = this.size++;
    } else {
        pointer = this.tail;
        this.tail = this.backward[pointer];
        oldValue = this.V[pointer];
        oldKey = this.K[pointer];
        delete this.items[oldKey];
    }
    // Storing key & value
    this.items[key] = pointer;
    this.K[pointer] = key;
    this.V[pointer] = value;
    // Moving the item at the front of the list
    this.forward[pointer] = this.head;
    this.backward[this.head] = pointer;
    this.head = pointer;
    // Return object if eviction took place, otherwise return null
    if (oldKey) {
        return {
            evicted: true,
            key: oldKey,
            value: oldValue
        };
    } else {
        return null;
    }
};
/**
 * Method used to check whether the key exists in the cache.
 *
 * @param  {any} key   - Key.
 * @return {boolean}
 */ LRUCache.prototype.has = function(key) {
    return key in this.items;
};
/**
 * Method used to get the value attached to the given key. Will move the
 * related key to the front of the underlying linked list.
 *
 * @param  {any} key   - Key.
 * @return {any}
 */ LRUCache.prototype.get = function(key) {
    var pointer = this.items[key];
    if (typeof pointer === 'undefined') return;
    this.splayOnTop(pointer);
    return this.V[pointer];
};
/**
 * Method used to get the value attached to the given key. Does not modify
 * the ordering of the underlying linked list.
 *
 * @param  {any} key   - Key.
 * @return {any}
 */ LRUCache.prototype.peek = function(key) {
    var pointer = this.items[key];
    if (typeof pointer === 'undefined') return;
    return this.V[pointer];
};
/**
 * Method used to iterate over the cache's entries using a callback.
 *
 * @param  {function}  callback - Function to call for each item.
 * @param  {object}    scope    - Optional scope.
 * @return {undefined}
 */ LRUCache.prototype.forEach = function(callback, scope) {
    scope = arguments.length > 1 ? scope : this;
    var i = 0, l = this.size;
    var pointer = this.head, keys = this.K, values = this.V, forward = this.forward;
    while(i < l){
        callback.call(scope, values[pointer], keys[pointer], this);
        pointer = forward[pointer];
        i++;
    }
};
/**
 * Method used to create an iterator over the cache's keys from most
 * recently used to least recently used.
 *
 * @return {Iterator}
 */ LRUCache.prototype.keys = function() {
    var i = 0, l = this.size;
    var pointer = this.head, keys = this.K, forward = this.forward;
    return new Iterator(function() {
        if (i >= l) return {
            done: true
        };
        var key = keys[pointer];
        i++;
        if (i < l) pointer = forward[pointer];
        return {
            done: false,
            value: key
        };
    });
};
/**
 * Method used to create an iterator over the cache's values from most
 * recently used to least recently used.
 *
 * @return {Iterator}
 */ LRUCache.prototype.values = function() {
    var i = 0, l = this.size;
    var pointer = this.head, values = this.V, forward = this.forward;
    return new Iterator(function() {
        if (i >= l) return {
            done: true
        };
        var value = values[pointer];
        i++;
        if (i < l) pointer = forward[pointer];
        return {
            done: false,
            value: value
        };
    });
};
/**
 * Method used to create an iterator over the cache's entries from most
 * recently used to least recently used.
 *
 * @return {Iterator}
 */ LRUCache.prototype.entries = function() {
    var i = 0, l = this.size;
    var pointer = this.head, keys = this.K, values = this.V, forward = this.forward;
    return new Iterator(function() {
        if (i >= l) return {
            done: true
        };
        var key = keys[pointer], value = values[pointer];
        i++;
        if (i < l) pointer = forward[pointer];
        return {
            done: false,
            value: [
                key,
                value
            ]
        };
    });
};
/**
 * Attaching the #.entries method to Symbol.iterator if possible.
 */ if (typeof Symbol !== 'undefined') LRUCache.prototype[Symbol.iterator] = LRUCache.prototype.entries;
/**
 * Convenience known methods.
 */ LRUCache.prototype.inspect = function() {
    var proxy = new Map();
    var iterator = this.entries(), step;
    while(step = iterator.next(), !step.done)proxy.set(step.value[0], step.value[1]);
    // Trick so that node displays the name of the constructor
    Object.defineProperty(proxy, 'constructor', {
        value: LRUCache,
        enumerable: false
    });
    return proxy;
};
if (typeof Symbol !== 'undefined') LRUCache.prototype[Symbol.for('nodejs.util.inspect.custom')] = LRUCache.prototype.inspect;
/**
 * Static @.from function taking an arbitrary iterable & converting it into
 * a structure.
 *
 * @param  {Iterable} iterable - Target iterable.
 * @param  {function} Keys     - Array class for storing keys.
 * @param  {function} Values   - Array class for storing values.
 * @param  {number}   capacity - Cache's capacity.
 * @return {LRUCache}
 */ LRUCache.from = function(iterable, Keys, Values, capacity) {
    if (arguments.length < 2) {
        capacity = iterables.guessLength(iterable);
        if (typeof capacity !== 'number') throw new Error('mnemonist/lru-cache.from: could not guess iterable length. Please provide desired capacity as last argument.');
    } else if (arguments.length === 2) {
        capacity = Keys;
        Keys = null;
        Values = null;
    }
    var cache = new LRUCache(Keys, Values, capacity);
    forEach(iterable, function(value, key) {
        cache.set(key, value);
    });
    return cache;
};
/**
 * Exporting.
 */ module.exports = LRUCache;
}}),
"[project]/node_modules/mnemonist/lru-cache-with-delete.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
/**
 * Mnemonist LRUCacheWithDelete
 * =============================
 *
 * An extension of LRUCache with delete functionality.
 */ var LRUCache = __turbopack_require__("[project]/node_modules/mnemonist/lru-cache.js [app-client] (ecmascript)"), forEach = __turbopack_require__("[project]/node_modules/obliterator/foreach.js [app-client] (ecmascript)"), typed = __turbopack_require__("[project]/node_modules/mnemonist/utils/typed-arrays.js [app-client] (ecmascript)"), iterables = __turbopack_require__("[project]/node_modules/mnemonist/utils/iterables.js [app-client] (ecmascript)");
// The only complication with deleting items is that the LRU's
// performance depends on having a fixed-size list of pointers; the
// doubly-linked-list is happy to expand and contract.
//
// On delete, we record the position of the former item's pointer in a
// list of "holes" in the pointer array. On insert, if there is a hole
// the new pointer slots in to fill the hole; otherwise, it is
// appended as usual. (Note: we are only talking here about the
// internal pointer list. setting or getting an item promotes it
// to the top of the LRU ranking no matter what came before)
function LRUCacheWithDelete(Keys, Values, capacity) {
    if (arguments.length < 2) {
        LRUCache.call(this, Keys);
    } else {
        LRUCache.call(this, Keys, Values, capacity);
    }
    var PointerArray = typed.getPointerArray(this.capacity);
    this.deleted = new PointerArray(this.capacity);
    this.deletedSize = 0;
}
for(var k in LRUCache.prototype)LRUCacheWithDelete.prototype[k] = LRUCache.prototype[k];
if (typeof Symbol !== 'undefined') LRUCacheWithDelete.prototype[Symbol.iterator] = LRUCache.prototype[Symbol.iterator];
/**
 * Method used to clear the structure.
 *
 * @return {undefined}
 */ LRUCacheWithDelete.prototype.clear = function() {
    LRUCache.prototype.clear.call(this);
    this.deletedSize = 0;
};
/**
 * Method used to set the value for the given key in the cache.
 *
 * @param  {any} key   - Key.
 * @param  {any} value - Value.
 * @return {undefined}
 */ LRUCacheWithDelete.prototype.set = function(key, value) {
    var pointer = this.items[key];
    // The key already exists, we just need to update the value and splay on top
    if (typeof pointer !== 'undefined') {
        this.splayOnTop(pointer);
        this.V[pointer] = value;
        return;
    }
    // The cache is not yet full
    if (this.size < this.capacity) {
        if (this.deletedSize > 0) {
            // If there is a "hole" in the pointer list, reuse it
            pointer = this.deleted[--this.deletedSize];
        } else {
            // otherwise append to the pointer list
            pointer = this.size;
        }
        this.size++;
    } else {
        pointer = this.tail;
        this.tail = this.backward[pointer];
        delete this.items[this.K[pointer]];
    }
    // Storing key & value
    this.items[key] = pointer;
    this.K[pointer] = key;
    this.V[pointer] = value;
    // Moving the item at the front of the list
    this.forward[pointer] = this.head;
    this.backward[this.head] = pointer;
    this.head = pointer;
};
/**
 * Method used to set the value for the given key in the cache
 *
 * @param  {any} key   - Key.
 * @param  {any} value - Value.
 * @return {{evicted: boolean, key: any, value: any}} An object containing the
 * key and value of an item that was overwritten or evicted in the set
 * operation, as well as a boolean indicating whether it was evicted due to
 * limited capacity. Return value is null if nothing was evicted or overwritten
 * during the set operation.
 */ LRUCacheWithDelete.prototype.setpop = function(key, value) {
    var oldValue = null;
    var oldKey = null;
    var pointer = this.items[key];
    // The key already exists, we just need to update the value and splay on top
    if (typeof pointer !== 'undefined') {
        this.splayOnTop(pointer);
        oldValue = this.V[pointer];
        this.V[pointer] = value;
        return {
            evicted: false,
            key: key,
            value: oldValue
        };
    }
    // The cache is not yet full
    if (this.size < this.capacity) {
        if (this.deletedSize > 0) {
            // If there is a "hole" in the pointer list, reuse it
            pointer = this.deleted[--this.deletedSize];
        } else {
            // otherwise append to the pointer list
            pointer = this.size;
        }
        this.size++;
    } else {
        pointer = this.tail;
        this.tail = this.backward[pointer];
        oldValue = this.V[pointer];
        oldKey = this.K[pointer];
        delete this.items[oldKey];
    }
    // Storing key & value
    this.items[key] = pointer;
    this.K[pointer] = key;
    this.V[pointer] = value;
    // Moving the item at the front of the list
    this.forward[pointer] = this.head;
    this.backward[this.head] = pointer;
    this.head = pointer;
    // Return object if eviction took place, otherwise return null
    if (oldKey) {
        return {
            evicted: true,
            key: oldKey,
            value: oldValue
        };
    } else {
        return null;
    }
};
/**
 * Method used to delete the entry for the given key in the cache.
 *
 * @param  {any} key   - Key.
 * @return {boolean}   - true if the item was present
 */ LRUCacheWithDelete.prototype.delete = function(key) {
    var pointer = this.items[key];
    if (typeof pointer === 'undefined') {
        return false;
    }
    delete this.items[key];
    if (this.size === 1) {
        this.size = 0;
        this.head = 0;
        this.tail = 0;
        this.deletedSize = 0;
        return true;
    }
    var previous = this.backward[pointer], next = this.forward[pointer];
    if (this.head === pointer) {
        this.head = next;
    }
    if (this.tail === pointer) {
        this.tail = previous;
    }
    this.forward[previous] = next;
    this.backward[next] = previous;
    this.size--;
    this.deleted[this.deletedSize++] = pointer;
    return true;
};
/**
 * Method used to remove and return the value for the given key in the cache.
 *
 * @param  {any} key                 - Key.
 * @param  {any} [missing=undefined] - Value to return if item is absent
 * @return {any} The value, if present; the missing indicator if absent
 */ LRUCacheWithDelete.prototype.remove = function(key, missing = undefined) {
    var pointer = this.items[key];
    if (typeof pointer === 'undefined') {
        return missing;
    }
    var dead = this.V[pointer];
    delete this.items[key];
    if (this.size === 1) {
        this.size = 0;
        this.head = 0;
        this.tail = 0;
        this.deletedSize = 0;
        return dead;
    }
    var previous = this.backward[pointer], next = this.forward[pointer];
    if (this.head === pointer) {
        this.head = next;
    }
    if (this.tail === pointer) {
        this.tail = previous;
    }
    this.forward[previous] = next;
    this.backward[next] = previous;
    this.size--;
    this.deleted[this.deletedSize++] = pointer;
    return dead;
};
/**
 * Static @.from function taking an arbitrary iterable & converting it into
 * a structure.
 *
 * @param  {Iterable} iterable - Target iterable.
 * @param  {function} Keys     - Array class for storing keys.
 * @param  {function} Values   - Array class for storing values.
 * @param  {number}   capacity - Cache's capacity.
 * @return {LRUCacheWithDelete}
 */ LRUCacheWithDelete.from = function(iterable, Keys, Values, capacity) {
    if (arguments.length < 2) {
        capacity = iterables.guessLength(iterable);
        if (typeof capacity !== 'number') throw new Error('mnemonist/lru-cache.from: could not guess iterable length. Please provide desired capacity as last argument.');
    } else if (arguments.length === 2) {
        capacity = Keys;
        Keys = null;
        Values = null;
    }
    var cache = new LRUCacheWithDelete(Keys, Values, capacity);
    forEach(iterable, function(value, key) {
        cache.set(key, value);
    });
    return cache;
};
module.exports = LRUCacheWithDelete;
}}),
"[project]/node_modules/@sanity/presentation/node_modules/mendoza/dist/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "applyPatch": (()=>applyPatch),
    "incremental": (()=>incrementalPatcher)
});
const OPS = [
    "Value",
    "Copy",
    "Blank",
    "ReturnIntoArray",
    "ReturnIntoObject",
    "ReturnIntoObjectSameKey",
    "PushField",
    "PushElement",
    "PushParent",
    "Pop",
    "PushFieldCopy",
    "PushFieldBlank",
    "PushElementCopy",
    "PushElementBlank",
    "ReturnIntoObjectPop",
    "ReturnIntoObjectSameKeyPop",
    "ReturnIntoArrayPop",
    "ObjectSetFieldValue",
    "ObjectCopyField",
    "ObjectDeleteField",
    "ArrayAppendValue",
    "ArrayAppendSlice",
    "StringAppendString",
    "StringAppendSlice"
];
class Patcher {
    constructor(model, root, patch){
        this.model = model, this.root = root, this.patch = patch, this.i = 0, this.inputStack = [], this.outputStack = [];
    }
    read() {
        return this.patch[this.i++];
    }
    process() {
        for(this.inputStack.push({
            value: this.root
        }), this.outputStack.push({
            value: this.root
        }); this.i < this.patch.length;){
            let opcode = this.read(), op = OPS[opcode];
            if (!op) throw new Error(`Unknown opcode: ${opcode}`);
            let processor = `process${op}`;
            this[processor].apply(this);
        }
        let entry = this.outputStack.pop();
        return this.finalizeOutput(entry);
    }
    inputEntry() {
        return this.inputStack[this.inputStack.length - 1];
    }
    inputKey(entry, idx) {
        return entry.keys || (entry.keys = this.model.objectGetKeys(entry.value).sort()), entry.keys[idx];
    }
    outputEntry() {
        return this.outputStack[this.outputStack.length - 1];
    }
    outputArray() {
        let entry = this.outputEntry();
        return entry.writeValue || (entry.writeValue = this.model.copyArray(entry.value)), entry.writeValue;
    }
    outputObject() {
        let entry = this.outputEntry();
        return entry.writeValue || (entry.writeValue = this.model.copyObject(entry.value)), entry.writeValue;
    }
    outputString() {
        let entry = this.outputEntry();
        return entry.writeValue || (entry.writeValue = this.model.copyString(entry.value)), entry.writeValue;
    }
    finalizeOutput(entry) {
        return entry.writeValue ? this.model.finalize(entry.writeValue) : entry.value;
    }
    // Processors:
    processValue() {
        let value = this.model.wrap(this.read());
        this.outputStack.push({
            value
        });
    }
    processCopy() {
        let input = this.inputEntry();
        this.outputStack.push({
            value: input.value
        });
    }
    processBlank() {
        this.outputStack.push({
            value: null
        });
    }
    processReturnIntoArray() {
        let entry = this.outputStack.pop(), result = this.finalizeOutput(entry), arr = this.outputArray();
        this.model.arrayAppendValue(arr, result);
    }
    processReturnIntoObject() {
        let key = this.read(), entry = this.outputStack.pop(), result = this.finalizeOutput(entry);
        result = this.model.markChanged(result);
        let obj = this.outputObject();
        this.model.objectSetField(obj, key, result);
    }
    processReturnIntoObjectSameKey() {
        let input = this.inputEntry(), entry = this.outputStack.pop(), result = this.finalizeOutput(entry), obj = this.outputObject();
        this.model.objectSetField(obj, input.key, result);
    }
    processPushField() {
        let idx = this.read(), entry = this.inputEntry(), key = this.inputKey(entry, idx), value = this.model.objectGetField(entry.value, key);
        this.inputStack.push({
            value,
            key
        });
    }
    processPushElement() {
        let idx = this.read(), entry = this.inputEntry(), value = this.model.arrayGetElement(entry.value, idx);
        this.inputStack.push({
            value
        });
    }
    processPop() {
        this.inputStack.pop();
    }
    processPushFieldCopy() {
        this.processPushField(), this.processCopy();
    }
    processPushFieldBlank() {
        this.processPushField(), this.processBlank();
    }
    processPushElementCopy() {
        this.processPushElement(), this.processCopy();
    }
    processPushElementBlank() {
        this.processPushElement(), this.processBlank();
    }
    processReturnIntoObjectPop() {
        this.processReturnIntoObject(), this.processPop();
    }
    processReturnIntoObjectSameKeyPop() {
        this.processReturnIntoObjectSameKey(), this.processPop();
    }
    processReturnIntoArrayPop() {
        this.processReturnIntoArray(), this.processPop();
    }
    processObjectSetFieldValue() {
        this.processValue(), this.processReturnIntoObject();
    }
    processObjectCopyField() {
        this.processPushField(), this.processCopy(), this.processReturnIntoObjectSameKey(), this.processPop();
    }
    processObjectDeleteField() {
        let idx = this.read(), entry = this.inputEntry(), key = this.inputKey(entry, idx), obj = this.outputObject();
        this.model.objectDeleteField(obj, key);
    }
    processArrayAppendValue() {
        let value = this.model.wrap(this.read()), arr = this.outputArray();
        this.model.arrayAppendValue(arr, value);
    }
    processArrayAppendSlice() {
        let left = this.read(), right = this.read(), str = this.outputArray(), val = this.inputEntry().value;
        this.model.arrayAppendSlice(str, val, left, right);
    }
    processStringAppendString() {
        let value = this.model.wrap(this.read()), str = this.outputString();
        this.model.stringAppendValue(str, value);
    }
    processStringAppendSlice() {
        let left = this.read(), right = this.read(), str = this.outputString(), val = this.inputEntry().value;
        this.model.stringAppendSlice(str, val, left, right);
    }
}
function utf8charSize(code) {
    return code >> 16 ? 4 : code >> 11 ? 3 : code >> 7 ? 2 : 1;
}
function utf8stringSize(str) {
    let b = 0;
    for(let i = 0; i < str.length; i++){
        let code = str.codePointAt(i), size = utf8charSize(code);
        size == 4 && i++, b += size;
    }
    return b;
}
function utf8resolveIndex(str, idx, start = 0) {
    let byteCount = start, ucsIdx = 0;
    for(ucsIdx = start; byteCount < idx; ucsIdx++){
        let code = str.codePointAt(ucsIdx), size = utf8charSize(code);
        size === 4 && ucsIdx++, byteCount += size;
    }
    return ucsIdx;
}
function commonPrefix(str, str2) {
    let len = Math.min(str.length, str2.length), b = 0;
    for(let i = 0; i < len;){
        let aPoint = str.codePointAt(i), bPoint = str2.codePointAt(i);
        if (aPoint !== bPoint) return b;
        let size = utf8charSize(aPoint);
        b += size, i += size === 4 ? 2 : 1;
    }
    return b;
}
function commonSuffix(str, str2, prefix = 0) {
    let len = Math.min(str.length, str2.length) - prefix, b = 0;
    for(let i = 0; i < len;){
        let aPoint = str.codePointAt(str.length - 1 - i), bPoint = str2.codePointAt(str2.length - 1 - i);
        if (aPoint !== bPoint) return b;
        let size = utf8charSize(aPoint);
        b += size, i += size === 4 ? 2 : 1;
    }
    return b;
}
class IncrementalModel {
    constructor(meta){
        this.meta = meta;
    }
    wrap(data) {
        return this.wrapWithMeta(data, this.meta, this.meta);
    }
    wrapWithMeta(data, startMeta, endMeta = this.meta) {
        return {
            data,
            startMeta,
            endMeta
        };
    }
    asObject(value) {
        if (!value.content) {
            let fields = {};
            for (let [key, val] of Object.entries(value.data))fields[key] = this.wrapWithMeta(val, value.startMeta);
            value.content = {
                type: "object",
                fields
            };
        }
        return value.content;
    }
    asArray(value) {
        if (!value.content) {
            let elements = value.data.map((item)=>this.wrapWithMeta(item, value.startMeta)), metas = elements.map(()=>this.meta);
            value.content = {
                type: "array",
                elements,
                metas
            };
        }
        return value.content;
    }
    asString(value) {
        if (!value.content) {
            let str = value.data, part = {
                value: str,
                utf8size: utf8stringSize(str),
                uses: [],
                startMeta: value.startMeta,
                endMeta: value.endMeta
            };
            value.content = this.stringFromParts([
                part
            ]);
        }
        return value.content;
    }
    stringFromParts(parts) {
        let str = {
            type: "string",
            parts
        };
        for (let part of parts)part.uses.push(str);
        return str;
    }
    objectGetKeys(value) {
        return value.content ? Object.keys(value.content.fields) : Object.keys(value.data);
    }
    objectGetField(value, key) {
        return this.asObject(value).fields[key];
    }
    arrayGetElement(value, idx) {
        return this.asArray(value).elements[idx];
    }
    finalize(content) {
        return this.updateEndMeta(content), {
            content,
            startMeta: this.meta,
            endMeta: this.meta
        };
    }
    markChanged(value) {
        return this.wrap(unwrap(value));
    }
    updateEndMeta(content) {
        if (content.type == "string") for (let part of content.parts)part.endMeta = this.meta;
        else if (content.type === "array") for (let val of content.elements)val.content && val.endMeta !== this.meta && this.updateEndMeta(val.content), val.endMeta = this.meta;
        else for (let val of Object.values(content.fields))val.content && val.endMeta !== this.meta && this.updateEndMeta(val.content), val.endMeta = this.meta;
    }
    copyString(value) {
        if (value) {
            let other = this.asString(value);
            return this.stringFromParts(other.parts.slice());
        } else return {
            type: "string",
            parts: []
        };
    }
    copyObject(value) {
        let obj = {
            type: "object",
            fields: {}
        };
        if (value) {
            let other = this.asObject(value);
            Object.assign(obj.fields, other.fields);
        }
        return obj;
    }
    copyArray(value) {
        let arr = value ? this.asArray(value) : null, elements = arr ? arr.elements : [], metas = arr ? arr.metas : [];
        return {
            type: "array",
            elements,
            metas
        };
    }
    objectSetField(target, key, value) {
        target.fields[key] = value;
    }
    objectDeleteField(target, key) {
        delete target.fields[key];
    }
    arrayAppendValue(target, value) {
        target.elements.push(value), target.metas.push(this.meta);
    }
    arrayAppendSlice(target, source, left, right) {
        let arr = this.asArray(source), samePosition = arr.elements.length === left;
        if (target.elements.push(...arr.elements.slice(left, right)), samePosition) target.metas.push(...arr.metas.slice(left, right));
        else for(let i = left; i < right; i++)target.metas.push(this.meta);
    }
    stringAppendValue(target, value) {
        let str = this.asString(value);
        for (let part of str.parts)this.stringAppendPart(target, part);
    }
    stringAppendPart(target, part) {
        target.parts.push(part), part.uses.push(target);
    }
    resolveStringPart(str, from, len) {
        if (len === 0) return from;
        for(let i = from; i < str.parts.length; i++){
            let part = str.parts[i];
            if (len === part.utf8size) return i + 1;
            if (len < part.utf8size) return this.splitString(part, len), i + 1;
            len -= part.utf8size;
        }
        throw new Error("splitting string out of bounds");
    }
    splitString(part, idx) {
        let leftValue, rightValue, leftSize = idx, rightSize = part.utf8size - leftSize;
        if (part.utf8size !== part.value.length) {
            let byteCount = 0;
            for(idx = 0; byteCount < leftSize; idx++){
                let code = part.value.codePointAt(idx), size = utf8charSize(code);
                size === 4 && idx++, byteCount += size;
            }
        }
        leftValue = part.value.slice(0, idx), rightValue = part.value.slice(idx);
        let newPart = {
            value: rightValue,
            utf8size: rightSize,
            uses: part.uses.slice(),
            startMeta: part.startMeta,
            endMeta: part.endMeta
        };
        part.value = leftValue, part.utf8size = leftSize;
        for (let use of part.uses){
            let ndx = use.parts.indexOf(part);
            if (ndx === -1) throw new Error("bug: mismatch between string parts and use.");
            use.parts.splice(ndx + 1, 0, newPart);
        }
    }
    stringAppendSlice(target, source, left, right) {
        let str = this.asString(source), firstPart = this.resolveStringPart(str, 0, left), lastPart = this.resolveStringPart(str, firstPart, right - left);
        for(let i = firstPart; i < lastPart; i++){
            let part = str.parts[i];
            this.stringAppendPart(target, part);
        }
    }
}
function wrap(data, meta) {
    return {
        data,
        startMeta: meta,
        endMeta: meta
    };
}
function unwrap(value) {
    if (typeof value.data < "u") return value.data;
    let result, content = value.content;
    switch(content.type){
        case "string":
            result = content.parts.map((part)=>part.value).join("");
            break;
        case "array":
            result = content.elements.map((val)=>unwrap(val));
            break;
        case "object":
            {
                result = {};
                for (let [key, val] of Object.entries(content.fields))result[key] = unwrap(val);
            }
    }
    return value.data = result, result;
}
function getType(value) {
    return value.content ? value.content.type : Array.isArray(value.data) ? "array" : value.data === null ? "null" : typeof value.data;
}
function rebaseValue(left, right) {
    let leftType = getType(left), rightType = getType(right);
    if (leftType !== rightType) return right;
    let leftModel = new IncrementalModel(left.endMeta), rightModel = new IncrementalModel(right.endMeta);
    switch(leftType){
        case "object":
            {
                let leftObj = leftModel.asObject(left), rightObj = rightModel.asObject(right), identicalFieldCount = 0, leftFieldCount = Object.keys(leftObj.fields).length, rightFieldCount = Object.keys(rightObj.fields).length;
                for (let [key, rightVal] of Object.entries(rightObj.fields)){
                    let leftVal = leftObj.fields[key];
                    leftVal && (rightObj.fields[key] = rebaseValue(leftVal, rightVal), rightObj.fields[key] === leftVal && identicalFieldCount++);
                }
                return leftFieldCount === rightFieldCount && leftFieldCount === identicalFieldCount ? left : right;
            }
        case "array":
            {
                let leftArr = leftModel.asArray(left), rightArr = rightModel.asArray(right);
                if (leftArr.elements.length !== rightArr.elements.length) break;
                let numRebased = 0;
                for(let i = 0; i < rightArr.elements.length; i++)rightArr.elements[i] = rebaseValue(leftArr.elements[i], rightArr.elements[i]), rightArr.elements[i] !== leftArr.elements[i] && numRebased++;
                return numRebased === 0 ? left : right;
            }
        case "null":
        case "boolean":
        case "number":
            {
                if (unwrap(left) === unwrap(right)) return left;
                break;
            }
        case "string":
            {
                let leftRaw = unwrap(left), rightRaw = unwrap(right);
                if (leftRaw === rightRaw) return left;
                let result = rightModel.copyString(null), prefix = commonPrefix(leftRaw, rightRaw), suffix = commonSuffix(leftRaw, rightRaw, prefix), rightLen = utf8stringSize(rightRaw), leftLen = utf8stringSize(leftRaw);
                0 < prefix && rightModel.stringAppendSlice(result, left, 0, prefix), prefix < rightLen - suffix && rightModel.stringAppendSlice(result, right, prefix, rightLen - suffix), leftLen - suffix < leftLen && rightModel.stringAppendSlice(result, left, leftLen - suffix, leftLen);
                let value = rightModel.finalize(result);
                if (unwrap(value) !== rightRaw) throw new Error("incorrect string rebase");
                return value;
            }
    }
    return right;
}
function applyPatch$1(left, patch, startMeta) {
    let model = new IncrementalModel(startMeta);
    return new Patcher(model, left, patch).process();
}
var incrementalPatcher = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    applyPatch: applyPatch$1,
    getType,
    rebaseValue,
    unwrap,
    wrap
});
class SimpleModel {
    wrap(data) {
        return data;
    }
    finalize(b) {
        return Array.isArray(b) ? b : b.data;
    }
    markChanged(value) {
        return value;
    }
    objectGetKeys(value) {
        return Object.keys(value);
    }
    objectGetField(value, key) {
        return value[key];
    }
    arrayGetElement(value, idx) {
        return value[idx];
    }
    copyObject(value) {
        let res = {
            type: "object",
            data: {}
        };
        if (value !== null) for (let [key, val] of Object.entries(value))res.data[key] = val;
        return res;
    }
    copyArray(value) {
        return value === null ? [] : value.slice();
    }
    copyString(value) {
        return {
            type: "string",
            data: value === null ? "" : value
        };
    }
    objectSetField(target, key, value) {
        target.data[key] = value;
    }
    objectDeleteField(target, key) {
        delete target.data[key];
    }
    arrayAppendValue(target, value) {
        target.push(value);
    }
    arrayAppendSlice(target, source, left, right) {
        target.push(...source.slice(left, right));
    }
    stringAppendSlice(target, source, left, right) {
        const sourceString = source, leftPos = utf8resolveIndex(sourceString, left), rightPos = utf8resolveIndex(sourceString, right, leftPos);
        target.data += sourceString.slice(leftPos, rightPos);
    }
    stringAppendValue(target, value) {
        target.data += value;
    }
}
function applyPatch(left, patch) {
    let root = left;
    return new Patcher(new SimpleModel(), root, patch).process();
}
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@sanity/presentation/dist/_chunks-es/hooks.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "useQueryParams": (()=>useQueryParams),
    "useRevalidate": (()=>useRevalidate)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$presentation$2f$node_modules$2f$react$2d$compiler$2d$runtime$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@sanity/presentation/node_modules/react-compiler-runtime/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
;
;
function useQueryParams(params) {
    const stringifiedParams = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"])({
        "useQueryParams.useMemo[stringifiedParams]": ()=>JSON.stringify(params || {})
    }["useQueryParams.useMemo[stringifiedParams]"], [
        params
    ]);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"])({
        "useQueryParams.useMemo": ()=>JSON.parse(stringifiedParams)
    }["useQueryParams.useMemo"], [
        stringifiedParams
    ]);
}
function useRevalidate(props) {
    const { refreshInterval } = props, shouldPause = useShouldPause(), [state, setState] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])("hit"), startRefresh = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useRevalidate.useCallback[startRefresh]": ()=>(setState("inflight"), ({
                "useRevalidate.useCallback[startRefresh]": ()=>setState("hit")
            })["useRevalidate.useCallback[startRefresh]"])
    }["useRevalidate.useCallback[startRefresh]"], []);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "useRevalidate.useEffect": ()=>{
            if (!refreshInterval || state !== "hit") return;
            const timeout = setTimeout({
                "useRevalidate.useEffect.timeout": ()=>setState("stale")
            }["useRevalidate.useEffect.timeout"], refreshInterval);
            return ({
                "useRevalidate.useEffect": ()=>clearTimeout(timeout)
            })["useRevalidate.useEffect"];
        }
    }["useRevalidate.useEffect"], [
        refreshInterval,
        state
    ]), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "useRevalidate.useEffect": ()=>{
            if (state !== "hit") return;
            const onFocus = {
                "useRevalidate.useEffect.onFocus": ()=>setState("stale")
            }["useRevalidate.useEffect.onFocus"];
            return window.addEventListener("focus", onFocus), ({
                "useRevalidate.useEffect": ()=>window.removeEventListener("focus", onFocus)
            })["useRevalidate.useEffect"];
        }
    }["useRevalidate.useEffect"], [
        refreshInterval,
        state
    ]), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "useRevalidate.useEffect": ()=>{
            shouldPause && state === "hit" && setState("stale"), !shouldPause && state === "stale" && setState("refresh");
        }
    }["useRevalidate.useEffect"], [
        shouldPause,
        state
    ]), [
        state,
        startRefresh
    ];
}
function useShouldPause() {
    const $ = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$presentation$2f$node_modules$2f$react$2d$compiler$2d$runtime$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["c"])(2), [online, setOnline] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])(!1);
    let t0, t1;
    $[0] === Symbol.for("react.memo_cache_sentinel") ? (t0 = ()=>{
        setOnline(navigator.onLine);
        const online2 = ()=>setOnline(!0), offline = ()=>setOnline(!1);
        return window.addEventListener("online", online2), window.addEventListener("offline", offline), ()=>{
            window.removeEventListener("online", online2), window.removeEventListener("offline", offline);
        };
    }, t1 = [], $[0] = t0, $[1] = t1) : (t0 = $[0], t1 = $[1]), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])(t0, t1);
    const visibilityState = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useSyncExternalStore"])(onVisibilityChange, _temp, _temp2);
    return !online || visibilityState === "hidden";
}
function _temp2() {
    return "hidden";
}
function _temp() {
    return document.visibilityState;
}
function onVisibilityChange(onStoreChange) {
    return document.addEventListener("visibilitychange", onStoreChange), ()=>document.removeEventListener("visibilitychange", onStoreChange);
}
;
 //# sourceMappingURL=hooks.js.map
}}),
"[project]/node_modules/@sanity/client/dist/csm.js [app-client] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "applySourceDocuments": (()=>applySourceDocuments),
    "resolveEditUrl": (()=>resolveEditUrl),
    "resolvedKeyedSourcePath": (()=>resolvedKeyedSourcePath)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$client$2f$dist$2f$_chunks$2d$es$2f$resolveEditInfo$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@sanity/client/dist/_chunks-es/resolveEditInfo.js [app-client] (ecmascript)");
;
;
const defaultUpdateFunction = (changed)=>changed;
function applySourceDocuments(result, resultSourceMap, getCachedDocument, updateFn = defaultUpdateFunction, perspective = "raw") {
    if (!resultSourceMap) return result;
    if (perspective !== "published" && perspective !== "raw" && perspective !== "previewDrafts") throw new Error(`Unknown perspective "${perspective}"`);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$client$2f$dist$2f$_chunks$2d$es$2f$resolveEditInfo$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["walkMap"])(JSON.parse(JSON.stringify(result)), (value, path)=>{
        const resolveMappingResult = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$client$2f$dist$2f$_chunks$2d$es$2f$resolveEditInfo$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["resolveMapping"])(path, resultSourceMap);
        if (!resolveMappingResult) return value;
        const { mapping, pathSuffix } = resolveMappingResult;
        if (mapping.type !== "value" || mapping.source.type !== "documentValue") return value;
        const sourceDocument = resultSourceMap.documents[mapping.source.document], sourcePath = resultSourceMap.paths[mapping.source.path];
        if (sourceDocument) {
            const parsedPath = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$client$2f$dist$2f$_chunks$2d$es$2f$resolveEditInfo$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parseJsonPath"])(sourcePath + pathSuffix), stringifiedPath = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$client$2f$dist$2f$_chunks$2d$es$2f$resolveEditInfo$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toString"])(parsedPath);
            if (stringifiedPath === "_id") return value;
            let cachedDocument;
            if (perspective === "previewDrafts" ? (cachedDocument = getCachedDocument(sourceDocument._id.startsWith(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$client$2f$dist$2f$_chunks$2d$es$2f$resolveEditInfo$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DRAFTS_PREFIX"]) ? sourceDocument : {
                ...sourceDocument,
                _id: `${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$client$2f$dist$2f$_chunks$2d$es$2f$resolveEditInfo$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DRAFTS_PREFIX"]}${sourceDocument._id}}`
            }), cachedDocument || (cachedDocument = getCachedDocument(sourceDocument._id.startsWith(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$client$2f$dist$2f$_chunks$2d$es$2f$resolveEditInfo$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DRAFTS_PREFIX"]) ? {
                ...sourceDocument,
                _id: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$client$2f$dist$2f$_chunks$2d$es$2f$resolveEditInfo$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getPublishedId"])(sourceDocument._id)
            } : sourceDocument)), cachedDocument && (cachedDocument = {
                ...cachedDocument,
                _id: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$client$2f$dist$2f$_chunks$2d$es$2f$resolveEditInfo$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getPublishedId"])(sourceDocument._id),
                _originalId: sourceDocument._id
            })) : cachedDocument = getCachedDocument(sourceDocument), !cachedDocument) return value;
            const changedValue = cachedDocument ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$client$2f$dist$2f$_chunks$2d$es$2f$resolveEditInfo$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["get"])(cachedDocument, stringifiedPath, value) : value;
            return value === changedValue ? value : updateFn(changedValue, {
                cachedDocument,
                previousValue: value,
                sourceDocument,
                sourcePath: parsedPath
            });
        }
        return value;
    });
}
function resolvedKeyedSourcePath(options) {
    const { keyedResultPath, pathSuffix, sourceBasePath } = options, inferredResultPath = pathSuffix === void 0 ? [] : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$client$2f$dist$2f$_chunks$2d$es$2f$resolveEditInfo$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parseJsonPath"])(pathSuffix), inferredPath = keyedResultPath.slice(keyedResultPath.length - inferredResultPath.length), inferredPathSuffix = inferredPath.length ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$client$2f$dist$2f$_chunks$2d$es$2f$resolveEditInfo$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsonPath"])(inferredPath).slice(1) : "";
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$client$2f$dist$2f$_chunks$2d$es$2f$resolveEditInfo$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parseJsonPath"])(sourceBasePath + inferredPathSuffix);
}
function resolveEditUrl(options) {
    const { resultSourceMap, studioUrl } = options, resultPath = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$client$2f$dist$2f$_chunks$2d$es$2f$resolveEditInfo$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["studioPathToJsonPath"])(options.resultPath), editInfo = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$client$2f$dist$2f$_chunks$2d$es$2f$resolveEditInfo$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["resolveEditInfo"])({
        resultPath,
        resultSourceMap,
        studioUrl
    });
    if (editInfo) return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$client$2f$dist$2f$_chunks$2d$es$2f$resolveEditInfo$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createEditUrl"])(editInfo);
}
;
 //# sourceMappingURL=csm.js.map
}}),
"[project]/node_modules/@sanity/presentation/dist/_chunks-es/LoaderQueries.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "default": (()=>LoaderQueries),
    "turboChargeResultIfSourceMap": (()=>turboChargeResultIfSourceMap)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/next/dist/compiled/react/jsx-runtime.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$presentation$2f$node_modules$2f$react$2d$compiler$2d$runtime$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@sanity/presentation/node_modules/react-compiler-runtime/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mnemonist$2f$lru$2d$cache$2d$with$2d$delete$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/mnemonist/lru-cache-with-delete.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sanity$2f$lib$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_import__("[project]/node_modules/sanity/lib/index.mjs [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$presentation$2f$dist$2f$_chunks$2d$es$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@sanity/presentation/dist/_chunks-es/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$comlink$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@sanity/comlink/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$presentation$2f$dist$2f$_chunks$2d$es$2f$PresentationToolGrantsCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@sanity/presentation/dist/_chunks-es/PresentationToolGrantsCheck.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$presentation$2f$node_modules$2f$mendoza$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@sanity/presentation/node_modules/mendoza/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$presentation$2f$dist$2f$_chunks$2d$es$2f$hooks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@sanity/presentation/dist/_chunks-es/hooks.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$client$2f$dist$2f$csm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_import__("[project]/node_modules/@sanity/client/dist/csm.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$client$2f$dist$2f$_chunks$2d$es$2f$resolveEditInfo$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@sanity/client/dist/_chunks-es/resolveEditInfo.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
function LoaderQueries(props) {
    const { liveDocument, controller, perspective: activePerspective, documentsOnPage, onLoadersConnection, onDocumentsOnPage } = props, [comlink, setComlink] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])(), [liveQueries, setLiveQueries] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])({}), projectId = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sanity$2f$lib$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["useProjectId"])(), dataset = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sanity$2f$lib$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["useDataset"])();
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "LoaderQueries.useEffect": ()=>{
            const interval = setInterval({
                "LoaderQueries.useEffect.interval": ()=>setLiveQueries({
                        "LoaderQueries.useEffect.interval": (liveQueries_0)=>{
                            if (Object.keys(liveQueries_0).length < 1) return liveQueries_0;
                            const now = Date.now();
                            if (!Object.values(liveQueries_0).some({
                                "LoaderQueries.useEffect.interval": (liveQuery)=>liveQuery.heartbeat !== !1 && now > liveQuery.receivedAt + liveQuery.heartbeat
                            }["LoaderQueries.useEffect.interval"])) return liveQueries_0;
                            const next = {};
                            for (const [key, value] of Object.entries(liveQueries_0))value.heartbeat !== !1 && now > value.receivedAt + value.heartbeat || (next[key] = value);
                            return next;
                        }
                    }["LoaderQueries.useEffect.interval"])
            }["LoaderQueries.useEffect.interval"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$presentation$2f$dist$2f$_chunks$2d$es$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MIN_LOADER_QUERY_LISTEN_HEARTBEAT_INTERVAL"]);
            return ({
                "LoaderQueries.useEffect": ()=>clearInterval(interval)
            })["LoaderQueries.useEffect"];
        }
    }["LoaderQueries.useEffect"], []), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "LoaderQueries.useEffect": ()=>{
            if (controller) {
                const comlink_0 = controller.createChannel({
                    name: "presentation",
                    connectTo: "loaders",
                    heartbeat: !0
                }, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$comlink$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createConnectionMachine"])().provide({
                    actors: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$presentation$2f$dist$2f$_chunks$2d$es$2f$PresentationToolGrantsCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createCompatibilityActors"])()
                }));
                return setComlink(comlink_0), comlink_0.onStatus(onLoadersConnection), comlink_0.on("loader/documents", {
                    "LoaderQueries.useEffect": (data)=>{
                        data.projectId === projectId && data.dataset === dataset && onDocumentsOnPage("loaders", // eslint-disable-next-line @typescript-eslint/no-explicit-any
                        data.perspective, data.documents);
                    }
                }["LoaderQueries.useEffect"]), comlink_0.on("loader/query-listen", {
                    "LoaderQueries.useEffect": (data_0)=>{
                        if (data_0.projectId === projectId && data_0.dataset === dataset) {
                            if (typeof data_0.heartbeat == "number" && data_0.heartbeat < __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$presentation$2f$dist$2f$_chunks$2d$es$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MIN_LOADER_QUERY_LISTEN_HEARTBEAT_INTERVAL"]) throw new Error(`Loader query listen heartbeat interval must be at least ${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$presentation$2f$dist$2f$_chunks$2d$es$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MIN_LOADER_QUERY_LISTEN_HEARTBEAT_INTERVAL"]}ms`);
                            setLiveQueries({
                                "LoaderQueries.useEffect": (prev)=>({
                                        ...prev,
                                        [(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$presentation$2f$dist$2f$_chunks$2d$es$2f$PresentationToolGrantsCheck$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getQueryCacheKey"])(data_0.query, data_0.params)]: {
                                            perspective: data_0.perspective,
                                            query: data_0.query,
                                            params: data_0.params,
                                            receivedAt: Date.now(),
                                            heartbeat: data_0.heartbeat ?? !1
                                        }
                                    })
                            }["LoaderQueries.useEffect"]);
                        }
                    }
                }["LoaderQueries.useEffect"]), comlink_0.start();
            }
        }
    }["LoaderQueries.useEffect"], [
        controller,
        dataset,
        onDocumentsOnPage,
        onLoadersConnection,
        projectId
    ]);
    const [cache] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])({
        "LoaderQueries.useState": ()=>new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mnemonist$2f$lru$2d$cache$2d$with$2d$delete$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$presentation$2f$dist$2f$_chunks$2d$es$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LIVE_QUERY_CACHE_SIZE"])
    }["LoaderQueries.useState"]), studioClient = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sanity$2f$lib$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["useClient"])({
        apiVersion: "2023-10-16"
    }), clientConfig = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"])({
        "LoaderQueries.useMemo[clientConfig]": ()=>studioClient.config()
    }["LoaderQueries.useMemo[clientConfig]"], [
        studioClient
    ]), client = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"])({
        "LoaderQueries.useMemo[client]": ()=>studioClient.withConfig({
                resultSourceMap: "withKeyArraySelector"
            })
    }["LoaderQueries.useMemo[client]"], [
        studioClient
    ]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "LoaderQueries.useEffect": ()=>{
            if (comlink) {
                const { projectId: projectId_0, dataset: dataset_0 } = clientConfig;
                comlink.post("loader/perspective", {
                    projectId: projectId_0,
                    dataset: dataset_0,
                    perspective: activePerspective
                });
            }
        }
    }["LoaderQueries.useEffect"], [
        comlink,
        clientConfig,
        activePerspective
    ]);
    const turboIds = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"])({
        "LoaderQueries.useMemo[turboIds]": ()=>{
            const documentsActuallyInUse = documentsOnPage.map({
                "LoaderQueries.useMemo[turboIds].documentsActuallyInUse": ({ _id })=>_id
            }["LoaderQueries.useMemo[turboIds].documentsActuallyInUse"]), ids = [
                ...new Set(documentsActuallyInUse)
            ], max = cache.capacity;
            return ids.length >= max && (ids.length = max), ids;
        }
    }["LoaderQueries.useMemo[turboIds]"], [
        cache.capacity,
        documentsOnPage
    ]), [documentsCacheLastUpdated, setDocumentsCacheLastUpdated] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])(0);
    return /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsxs"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Fragment"], {
        children: [
            /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(Turbo, {
                cache,
                client,
                turboIds,
                setDocumentsCacheLastUpdated
            }),
            Object.entries(liveQueries).map(([key_0, { query, params, perspective }])=>/* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(QuerySubscription, {
                    cache,
                    projectId: clientConfig.projectId,
                    dataset: clientConfig.dataset,
                    perspective,
                    query,
                    params,
                    comlink,
                    client,
                    refreshInterval: activePerspective ? 2e3 : 0,
                    liveDocument,
                    documentsCacheLastUpdated
                }, `${key_0}${perspective}`))
        ]
    });
}
const Turbo = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["memo"])(function(props) {
    const $ = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$presentation$2f$node_modules$2f$react$2d$compiler$2d$runtime$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["c"])(22), { cache, client, turboIds, setDocumentsCacheLastUpdated } = props;
    let t0;
    $[0] === Symbol.for("react.memo_cache_sentinel") ? (t0 = [], $[0] = t0) : t0 = $[0];
    const [batch, setBatch] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])(t0);
    let t1, t2;
    $[1] !== batch || $[2] !== cache || $[3] !== turboIds ? (t1 = ()=>{
        const batchSet = new Set(batch.flat()), nextBatch = /* @__PURE__ */ new Set();
        for (const turboId of turboIds)!batchSet.has(turboId) && !cache.has(turboId) && nextBatch.add(turboId);
        const nextBatchSlice = [
            ...nextBatch
        ].slice(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$presentation$2f$dist$2f$_chunks$2d$es$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LIVE_QUERY_CACHE_BATCH_SIZE"]);
        nextBatchSlice.length !== 0 && setBatch((prevBatch)=>[
                ...prevBatch.slice(-__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$presentation$2f$dist$2f$_chunks$2d$es$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LIVE_QUERY_CACHE_BATCH_SIZE"]),
                nextBatchSlice
            ]);
    }, t2 = [
        batch,
        cache,
        turboIds
    ], $[1] = batch, $[2] = cache, $[3] = turboIds, $[4] = t1, $[5] = t2) : (t1 = $[4], t2 = $[5]), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])(t1, t2);
    let t3, t4;
    $[6] !== cache || $[7] !== client || $[8] !== setDocumentsCacheLastUpdated ? (t3 = ()=>{
        const subscription = client.listen("*", {}, {
            events: [
                "mutation"
            ],
            effectFormat: "mendoza",
            includePreviousRevision: !1,
            includeResult: !1,
            tag: "presentation-loader"
        }).subscribe((update)=>{
            if (update.type === "mutation" && update.transition === "disappear" && cache.delete(update.documentId) && setDocumentsCacheLastUpdated(Date.now()), update.type !== "mutation" || !update.effects?.apply?.length) return;
            const cachedDocument = cache.peek(update.documentId);
            if (cachedDocument) {
                const patchDoc = {
                    ...cachedDocument
                };
                delete patchDoc._rev;
                const patchedDocument = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$presentation$2f$node_modules$2f$mendoza$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["applyPatch"])(patchDoc, update.effects.apply);
                cache.set(update.documentId, patchedDocument), setDocumentsCacheLastUpdated(Date.now());
            }
        });
        return ()=>subscription.unsubscribe();
    }, t4 = [
        cache,
        client,
        setDocumentsCacheLastUpdated
    ], $[6] = cache, $[7] = client, $[8] = setDocumentsCacheLastUpdated, $[9] = t3, $[10] = t4) : (t3 = $[9], t4 = $[10]), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])(t3, t4);
    let t5;
    if ($[11] !== batch || $[12] !== cache || $[13] !== client || $[14] !== setDocumentsCacheLastUpdated) {
        let t62;
        $[16] !== cache || $[17] !== client || $[18] !== setDocumentsCacheLastUpdated ? (t62 = (ids)=>/* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(GetDocuments, {
                cache,
                client,
                ids,
                setDocumentsCacheLastUpdated
            }, JSON.stringify(ids)), $[16] = cache, $[17] = client, $[18] = setDocumentsCacheLastUpdated, $[19] = t62) : t62 = $[19], t5 = batch.map(t62), $[11] = batch, $[12] = cache, $[13] = client, $[14] = setDocumentsCacheLastUpdated, $[15] = t5;
    } else t5 = $[15];
    let t6;
    return $[20] !== t5 ? (t6 = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jsx"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$jsx$2d$runtime$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Fragment"], {
        children: t5
    }), $[20] = t5, $[21] = t6) : t6 = $[21], t6;
}), GetDocuments = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["memo"])(function(props) {
    const $ = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$presentation$2f$node_modules$2f$react$2d$compiler$2d$runtime$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["c"])(6), { client, cache, ids, setDocumentsCacheLastUpdated } = props;
    let t0, t1;
    return $[0] !== cache || $[1] !== client || $[2] !== ids || $[3] !== setDocumentsCacheLastUpdated ? (t0 = ()=>{
        const missingIds = ids.filter((id)=>!cache.has(id));
        missingIds.length !== 0 && client.getDocuments(missingIds).then((documents)=>{
            for (const doc of documents)doc && doc?._id && (cache.set(doc._id, doc), setDocumentsCacheLastUpdated(Date.now()));
        }, console.error);
    }, t1 = [
        cache,
        client,
        ids,
        setDocumentsCacheLastUpdated
    ], $[0] = cache, $[1] = client, $[2] = ids, $[3] = setDocumentsCacheLastUpdated, $[4] = t0, $[5] = t1) : (t0 = $[4], t1 = $[5]), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])(t0, t1), null;
});
GetDocuments.displayName = "GetDocuments";
function QuerySubscription(props) {
    const $ = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$presentation$2f$node_modules$2f$react$2d$compiler$2d$runtime$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["c"])(20), { cache, projectId, dataset, perspective, query, client, refreshInterval, liveDocument, comlink, documentsCacheLastUpdated } = props, params = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$presentation$2f$dist$2f$_chunks$2d$es$2f$hooks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useQueryParams"])(props.params);
    let t0;
    $[0] !== cache || $[1] !== client || $[2] !== documentsCacheLastUpdated || $[3] !== liveDocument || $[4] !== params || $[5] !== perspective || $[6] !== query || $[7] !== refreshInterval ? (t0 = {
        cache,
        client,
        liveDocument,
        params,
        perspective,
        query,
        refreshInterval,
        documentsCacheLastUpdated
    }, $[0] = cache, $[1] = client, $[2] = documentsCacheLastUpdated, $[3] = liveDocument, $[4] = params, $[5] = perspective, $[6] = query, $[7] = refreshInterval, $[8] = t0) : t0 = $[8];
    const data = useQuerySubscription(t0), result = data?.result, resultSourceMap = data?.resultSourceMap, tags = data?.tags;
    let t1, t2;
    return $[9] !== comlink || $[10] !== dataset || $[11] !== params || $[12] !== perspective || $[13] !== projectId || $[14] !== query || $[15] !== result || $[16] !== resultSourceMap || $[17] !== tags ? (t1 = ()=>{
        resultSourceMap && comlink?.post("loader/query-change", {
            projectId,
            dataset,
            perspective,
            query,
            params,
            result,
            resultSourceMap,
            tags
        });
    }, t2 = [
        comlink,
        dataset,
        params,
        perspective,
        projectId,
        query,
        result,
        resultSourceMap,
        tags
    ], $[9] = comlink, $[10] = dataset, $[11] = params, $[12] = perspective, $[13] = projectId, $[14] = query, $[15] = result, $[16] = resultSourceMap, $[17] = tags, $[18] = t1, $[19] = t2) : (t1 = $[18], t2 = $[19]), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])(t1, t2), null;
}
function useQuerySubscription(props) {
    const { cache, liveDocument, client, refreshInterval, query, params, perspective, documentsCacheLastUpdated } = props, [snapshot, setSnapshot] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])(null), { projectId: projectId_0, dataset: dataset_0 } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"])({
        "useQuerySubscription.useMemo": ()=>{
            const { projectId, dataset } = client.config();
            return {
                projectId,
                dataset
            };
        }
    }["useQuerySubscription.useMemo"], [
        client
    ]), [error, setError] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])(null);
    if (error) throw error;
    const [revalidate, startRefresh] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$presentation$2f$dist$2f$_chunks$2d$es$2f$hooks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRevalidate"])({
        refreshInterval
    }), shouldRefetch = revalidate === "refresh" || revalidate === "inflight";
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "useQuerySubscription.useEffect": ()=>{
            if (!shouldRefetch) return;
            let fulfilled = !1, fetching = !1;
            const controller = new AbortController();
            async function effect() {
                const { signal } = controller;
                fetching = !0;
                const { result, resultSourceMap, syncTags } = await client.fetch(query, params, {
                    tag: "presentation-loader",
                    signal,
                    perspective,
                    filterResponse: !1
                });
                fetching = !1, signal.aborted || (setSnapshot({
                    result,
                    resultSourceMap,
                    tags: syncTags
                }), fulfilled = !0);
            }
            const onFinally = startRefresh();
            return effect().catch({
                "useQuerySubscription.useEffect": (error_0)=>{
                    fetching = !1, error_0.name !== "AbortError" && setError(error_0);
                }
            }["useQuerySubscription.useEffect"]).finally(onFinally), ({
                "useQuerySubscription.useEffect": ()=>{
                    !fulfilled && !fetching && controller.abort();
                }
            })["useQuerySubscription.useEffect"];
        }
    }["useQuerySubscription.useEffect"], [
        client,
        dataset_0,
        liveDocument,
        params,
        perspective,
        projectId_0,
        query,
        shouldRefetch,
        startRefresh
    ]), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useMemo"])({
        "useQuerySubscription.useMemo": ()=>documentsCacheLastUpdated && snapshot?.resultSourceMap ? {
                result: turboChargeResultIfSourceMap(cache, liveDocument, snapshot.result, perspective, snapshot.resultSourceMap),
                resultSourceMap: snapshot.resultSourceMap
            } : snapshot
    }["useQuerySubscription.useMemo"], [
        cache,
        documentsCacheLastUpdated,
        liveDocument,
        perspective,
        snapshot
    ]);
}
let warnedAboutCrossDatasetReference = !1;
function turboChargeResultIfSourceMap(cache, liveDocument, result, perspective, resultSourceMap) {
    if (perspective === "raw") throw new Error("turboChargeResultIfSourceMap does not support raw perspective");
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$client$2f$dist$2f$csm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["applySourceDocuments"])(result, resultSourceMap, (sourceDocument)=>{
        if (sourceDocument._projectId) {
            warnedAboutCrossDatasetReference || (console.warn("Cross dataset references are not supported yet, ignoring source document", sourceDocument), warnedAboutCrossDatasetReference = !0);
            return;
        }
        return liveDocument?._id && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$client$2f$dist$2f$_chunks$2d$es$2f$resolveEditInfo$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getPublishedId"])(liveDocument._id) === (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sanity$2f$client$2f$dist$2f$_chunks$2d$es$2f$resolveEditInfo$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getPublishedId"])(sourceDocument._id) ? liveDocument : cache.get(sourceDocument._id);
    }, // eslint-disable-next-line @typescript-eslint/no-explicit-any
    (changedValue, { previousValue })=>typeof changedValue == "number" && typeof previousValue == "string" ? `${changedValue}` : changedValue, perspective);
}
;
 //# sourceMappingURL=LoaderQueries.js.map
}}),
}]);

//# sourceMappingURL=node_modules_5e2a24._.js.map